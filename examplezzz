
has_one(:venue,
  args: ->(args) ->{
    if ctx[:current_user].admin?
      args.input_field :admin_arg, type: "Blah"
    end
  }
)

bills: [
  {
    id: 1,
    order_items: [
      {
        id: 2,
        cost: 4
      }
    ]
  }
]

class BillObjectType < RailsQL::Type
  kind :object
  field :id

  can :query, :id
end

class BillInputObject < RailsQL::Type
  kind :input_object
  field :id

  can :input, :id
end

# bill.rb
{
  :InputObject
  :Object
}.each do |kind_sym|
  Class.new(RailsQL::Types.const_get(kind_sym))
  class kind_sym::Bill < RailsQL::Types.const_get(kind_sym)
    field :id

    action = parent.kind_sym == :input_object ? :input : :query
    can action, :id
  end
end

Bill::InputObjectType
Bill::ObjectType

InputObjectType::Bill
ObjectType::Bill

# -------
Bills::InputObject
   input_field :id, required: true

class GodMutation < RailsQL::Type
  field(:createBill,
    type: "Bill::Object",
    args: (args)->{
      args.field :bill, type: "Bill::InputObject", required: true
      args.field :bills, type: "[Bills::InputObject!]"
      # bills: null OR [{}]
    },
    resolve: ->(args, child_query) {
      bill = Bill.create(args[:bill])
      Bill.where{id == bill.id}.merge(child_query).first
    }
  )

  can :mutate, :createBill
end

createBill: {
  id: 1,
  items: [{id: 1}]
}


class Venue < RailsQL::Type
  kind :object

  has_many :bills, type: "BillType"

  can [:query], :bills
end

# Class.new + class eval
# Creates Bill::InputObject and Bill::Object
::Bill = RailsQL.object_and_input do
  name (kind == :object) ? "Bill" : "BillInputObject"

  if kind == :object
    field :id
  end

  can [:query], :id
end

class Bill < RailsQL::Type
  kind :object
  name (kind == :object) ? "Bill" : "BillInputObject"

  if kind == :object
    field :id
  end

  can [:query], :id
end

query {
  venue {
    bills {
      id
    }
  }
}

Runner(query_root: Schema, mutation_root: GodMutation)
calls Visitor

GodMutation.new fields: createBill <- has args BillInputType
  BillObjectType.model = Bill

Schema
 createBill

mutation {
  createBill(
    bill: {id: 1}
  ){
    id
    items {
      id
    }
  }
}


mutate {
  updateBill(
    id: 1,
    bill: {name: "updated bill name"}
  ){
    id
    name
  }
}


# --------
1. Refactor Base and InputObject, FieldDefinition and InputFieldDefinition to combine shared-logic [in progress]
2. Implement can :mutate and can :query (aliases), can :input [in progress]
3. Add mutation support to Visitor [done]
4. Add mutation root option to Runner [done]
5. Switch to 8.0 (GodMutation for menu_item)
---
6. Introspection fix-up and additions

More Features
* Type Name Introspection (__typename field on all types)
* Variables
* List and Non-Null as standalone anonomous types + syntax for fields
* Directives
* Field Aliases
